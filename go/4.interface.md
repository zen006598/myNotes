# interface

- `interface` 是一組方法簽名的組合，我們透過 `interface` 來定義物件的一組行為
- 隱式 `interface`，當一個類型（例如一個 `struct`）只要擁有某個接口所要求的所有方法，編譯器就會自動認定該類型實作了這個接口，而不需要在定義類型時明確聲明「實作了某個接口」
- 鴨子類型
- 空接口 `interface{}` 與類型斷言
- `interface` 組合
- naming convention `-er`

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	w1 := Character{
		Hp: 100, Mp: 50, Atk: 10, Type: Warrior_,
	}

	a1 := Character{
		Hp: 100, Mp: 50, Atk: 10, Type: Archer_,
	}

	w1.Slash()
	a1.Shooting()
}

type Warrior interface {
	Slash()
}

type Archer interface {
	Shooting()
}

type Character struct {
	Hp   int
	Mp   int
	Atk  int
	Type CharacterType
}

func (c Character) Slash() {
	fmt.Println("Slashes with", c.Atk)
}

func (c Character) Shooting() {
	fmt.Println("Shoots with", c.Atk)
}

func (c Character) Attack() {
	fmt.Println("Attack with " + strconv.Itoa(c.Atk))
}

func (w *Character) ChangeJob(ct CharacterType) {
	w.Type = ct
}

type CharacterType byte

const (
	Warrior_ CharacterType = iota
	Archer_
)

```

## 空 interface
